"use strict";(globalThis.webpackChunkamigo_docs=globalThis.webpackChunkamigo_docs||[]).push([[6535],{8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(6540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},9377:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"manual/define-problem/variables","title":"Variables","description":"Amigo components work with several types of variables, each serving a distinct purpose in defining optimization problems. Understanding these variable types is essential for building Amigo models.","source":"@site/docs/manual/define-problem/variables.md","sourceDirName":"manual/define-problem","slug":"/manual/define-problem/variables","permalink":"/amigo/docs/manual/define-problem/variables","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Components","permalink":"/amigo/docs/manual/define-problem/components"},"next":{"title":"Constraints","permalink":"/amigo/docs/manual/define-problem/constraints"}}');var t=s(4848),a=s(8453);const l={sidebar_position:2},o="Variables",r={},d=[{value:"Inputs",id:"inputs",level:2},{value:"Scalar Inputs",id:"scalar-inputs",level:3},{value:"Vector Inputs",id:"vector-inputs",level:3},{value:"Matrix Inputs",id:"matrix-inputs",level:3},{value:"With Units and Labels",id:"with-units-and-labels",level:3},{value:"Outputs",id:"outputs",level:2},{value:"Constants",id:"constants",level:2},{value:"Data",id:"data",level:2},{value:"Intermediate Variables",id:"intermediate-variables",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"variables",children:"Variables"})}),"\n",(0,t.jsx)(n.p,{children:"Amigo components work with several types of variables, each serving a distinct purpose in defining optimization problems. Understanding these variable types is essential for building Amigo models."}),"\n",(0,t.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,t.jsx)(n.p,{children:"Inputs are design variables that the optimizer can modify during the optimization process. They represent the degrees of freedom in your problem."}),"\n",(0,t.jsx)(n.h3,{id:"scalar-inputs",children:"Scalar Inputs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'self.add_input("x", value=1.0, lower=-10.0, upper=10.0)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"vector-inputs",children:"Vector Inputs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Define a 3-element vector\nself.add_input("forces", shape=(3,), value=0.0, lower=-100.0, upper=100.0)\n\n# Access individual elements\ndef compute(self):\n    forces = self.inputs["forces"]\n    fx = forces[0]\n    fy = forces[1]\n    fz = forces[2]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"matrix-inputs",children:"Matrix Inputs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Define a 3x3 matrix\nself.add_input("K", shape=(3, 3))\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-units-and-labels",children:"With Units and Labels"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'self.add_input("velocity", value=10.0, units="m/s", label="state")\nself.add_input("force", value=100.0, units="N", label="control")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"label"})," parameter is useful for grouping related variables, especially in optimal control problems where you might label certain inputs as ",(0,t.jsx)(n.code,{children:'"state"'})," or ",(0,t.jsx)(n.code,{children:'"control"'}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"outputs",children:"Outputs"}),"\n",(0,t.jsx)(n.p,{children:"Outputs are computed quantities that can be linked to inputs of other components. They enable component coupling in multidisciplinary systems."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Scalar output\nself.add_output("lift", units="N")\n\n# Vector output\nself.add_output("stress", shape=(3,))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Outputs are computed in the ",(0,t.jsx)(n.code,{children:"compute()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def compute(self):\n    velocity = self.inputs["velocity"]\n    self.outputs["lift"] = 0.5 * 1.225 * velocity**2 * 10.0  # Simplified\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Outputs can be linked to inputs of other components using ",(0,t.jsx)(n.code,{children:"model.link()"}),", enabling data flow between disciplines."]})}),"\n",(0,t.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,t.jsxs)(n.p,{children:["Constants are compile-time values that do not change during optimization. They are compiled as ",(0,t.jsx)(n.code,{children:"constexpr"})," in the generated C++ code for maximum performance."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'self.add_constant("pi", value=3.14159)\nself.add_constant("g", value=9.81, units="m/s^2")\nself.add_constant("E", value=200e9, units="Pa")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Constants are accessed in ",(0,t.jsx)(n.code,{children:"compute()"})," just like inputs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def compute(self):\n    g = self.constants["g"]\n    mass = self.inputs["mass"]\n    self.outputs["weight"] = mass * g\n'})}),"\n",(0,t.jsx)(n.h2,{id:"data",children:"Data"}),"\n",(0,t.jsx)(n.p,{children:"Data variables allow you to pass external information into the problem that is not optimized but may change between solves."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'self.add_data("temperature_field", shape=(100, 100))\nself.add_data("boundary_conditions", shape=(10,))\n'})}),"\n",(0,t.jsx)(n.p,{children:"Data is useful for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"External loads or boundary conditions"}),"\n",(0,t.jsx)(n.li,{children:"Mesh data or geometry information"}),"\n",(0,t.jsx)(n.li,{children:"Parameters for sensitivity studies"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"intermediate-variables",children:"Intermediate Variables"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"self.vars"})," dictionary stores intermediate computation results. These variables are symbolic and participate in automatic differentiation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def compute(self):\n    q = self.inputs["q"]\n    \n    # Compute and store intermediate values\n    self.vars["sint"] = am.sin(q[1])\n    self.vars["cost"] = am.cos(q[1])\n    \n    # Use intermediate variables\n    sint = self.vars["sint"]\n    cost = self.vars["cost"]\n    \n    self.outputs["rotation"] = [cost, sint]\n'})}),"\n",(0,t.jsx)(n.p,{children:"Intermediate variables help:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Organize complex computations"}),"\n",(0,t.jsx)(n.li,{children:"Avoid repeating calculations"}),"\n",(0,t.jsx)(n.li,{children:"Improve code readability"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Intermediate variables in ",(0,t.jsx)(n.code,{children:"self.vars"})," are automatically included in the automatic differentiation process."]})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);