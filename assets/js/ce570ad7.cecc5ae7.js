"use strict";(globalThis.webpackChunkamigo_docs=globalThis.webpackChunkamigo_docs||[]).push([[2325],{7443:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"category","label":"Getting started","items":[{"type":"link","href":"/amigo/docs/getting-started/introduction","label":"Introduction","docId":"getting-started/introduction","unlisted":false},{"type":"link","href":"/amigo/docs/getting-started/installation","label":"Installation","docId":"getting-started/installation","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Manual","items":[{"type":"category","label":"Define a problem","items":[{"type":"link","href":"/amigo/docs/manual/define-problem/components","label":"Components","docId":"manual/define-problem/components","unlisted":false},{"type":"link","href":"/amigo/docs/manual/define-problem/variables","label":"Variables","docId":"manual/define-problem/variables","unlisted":false},{"type":"link","href":"/amigo/docs/manual/define-problem/constraints","label":"Constraints","docId":"manual/define-problem/constraints","unlisted":false},{"type":"link","href":"/amigo/docs/manual/define-problem/objectives","label":"Objectives","docId":"manual/define-problem/objectives","unlisted":false},{"type":"link","href":"/amigo/docs/manual/define-problem/models","label":"Models","docId":"manual/define-problem/models","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","href":"/amigo/docs/manual/set-initial-guess","label":"Set an initial guess","docId":"manual/set-initial-guess","unlisted":false},{"type":"link","href":"/amigo/docs/manual/solve-problem","label":"Solve a problem","docId":"manual/solve-problem","unlisted":false},{"type":"link","href":"/amigo/docs/manual/solve-on-gpu","label":"Solve on GPU","docId":"manual/solve-on-gpu","unlisted":false},{"type":"link","href":"/amigo/docs/manual/compute-flow","label":"Compute flow","docId":"manual/compute-flow","unlisted":false},{"type":"link","href":"/amigo/docs/manual/plot-solution","label":"Plot a solution","docId":"manual/plot-solution","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API reference","items":[{"type":"link","href":"/amigo/docs/api/overview","label":"API Overview","docId":"api/overview","unlisted":false},{"type":"link","href":"/amigo/docs/api/component","label":"Component API","docId":"api/component","unlisted":false},{"type":"link","href":"/amigo/docs/api/model","label":"Model API","docId":"api/model","unlisted":false},{"type":"link","href":"/amigo/docs/api/optimizer","label":"Optimizer API","docId":"api/optimizer","unlisted":false}],"collapsed":true,"collapsible":true}],"tutorialsSidebar":[{"type":"category","label":"Tutorials and background","items":[{"type":"link","href":"/amigo/docs/tutorials/intro","label":"Getting Started","docId":"tutorials/intro","unlisted":false},{"type":"category","label":"Theory","items":[{"type":"link","href":"/amigo/docs/tutorials/background/discretization-methods","label":"Discretization Methods","docId":"tutorials/background/discretization-methods","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/background/direct-collocation","label":"Direct Collocation","docId":"tutorials/background/direct-collocation","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/background/shooting-methods","label":"Shooting Methods","docId":"tutorials/background/shooting-methods","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/background/automatic-differentiation","label":"Automatic Differentiation","docId":"tutorials/background/automatic-differentiation","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/background/interior-point-methods","label":"Interior Point Methods","docId":"tutorials/background/interior-point-methods","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Tutorials","items":[{"type":"link","href":"/amigo/docs/tutorials/cart-pole","label":"Cart-Pole Problem","docId":"tutorials/cart-pole","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/euler_beam","label":"Euler-Bernoulli Beam Optimization","docId":"tutorials/euler_beam","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true}],"examplesSidebar":[{"type":"category","label":"Examples","items":[{"type":"link","href":"/amigo/docs/examples/overview","label":"Examples browser","docId":"examples/overview","unlisted":false},{"type":"category","label":"List of examples","items":[{"type":"link","href":"/amigo/docs/tutorials/hang-glider","label":"Hang Glider","docId":"tutorials/hang-glider","unlisted":false},{"type":"link","href":"/amigo/docs/tutorials/free-flying-robot","label":"Free Flying Robot","docId":"tutorials/free-flying-robot","unlisted":false},{"type":"link","href":"/amigo/docs/examples/brachistochrone","label":"The Brachistochrone Problem","docId":"examples/brachistochrone","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true}]},"docs":{"api/component":{"id":"api/component","title":"Component API","description":"Component API documentation will be added in a future release.","sidebar":"docsSidebar"},"api/model":{"id":"api/model","title":"Model API","description":"Model API documentation will be added in a future release.","sidebar":"docsSidebar"},"api/optimizer":{"id":"api/optimizer","title":"Optimizer API","description":"Optimizer API documentation will be added in a future release.6","sidebar":"docsSidebar"},"api/overview":{"id":"api/overview","title":"API Overview","description":"API documentation will be added in a future release.","sidebar":"docsSidebar"},"examples/brachistochrone":{"id":"examples/brachistochrone","title":"The Brachistochrone Problem","description":"The brachistochrone problem is a classic problem in the calculus of variations, first posed by Johann Bernoulli in 1696. The name comes from the Greek words brachistos (shortest) and chronos (time). The problem asks: given two points at different heights, what is the path along which a particle will slide from the higher point to the lower point in the shortest time, under the influence of gravity alone?","sidebar":"examplesSidebar"},"examples/overview":{"id":"examples/overview","title":"overview","description":"{/ Expandable content /}","sidebar":"examplesSidebar"},"getting-started/citing":{"id":"getting-started/citing","title":"Citing Amigo","description":"Citation information will be provided in a future release."},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"To install Amigo, please use pip in your Python environment:","sidebar":"docsSidebar"},"getting-started/introduction":{"id":"getting-started/introduction","title":"Introduction","description":"Welcome to Amigo - A friendly library for multidisciplinary design optimization (MDO) on high-performance computing (HPC) resources.","sidebar":"docsSidebar"},"manual/compute-flow":{"id":"manual/compute-flow","title":"Compute Flow","description":"This page is under construction and will be updated soon.","sidebar":"docsSidebar"},"manual/define-problem/components":{"id":"manual/define-problem/components","title":"Components","description":"The Component class is the foundation of Amigo. All analysis and computation in Amigo occurs within classes that inherit from amigo.Component. A component encapsulates a computational model with well-defined inputs, outputs, constraints, and objectives.","sidebar":"docsSidebar"},"manual/define-problem/constraints":{"id":"manual/define-problem/constraints","title":"Constraints","description":"Constraints define the feasible region for your optimization problem. They specify conditions that must be satisfied by the solution.","sidebar":"docsSidebar"},"manual/define-problem/models":{"id":"manual/define-problem/models","title":"Models","description":"The Model class is responsible for assembling individual components into a complete optimization problem. It manages component instantiation, variable linking, code generation, and compilation.","sidebar":"docsSidebar"},"manual/define-problem/objectives":{"id":"manual/define-problem/objectives","title":"Objectives","description":"The objective function defines the quantity to be minimized during optimization. Every optimization problem in Amigo must have at least one objective.","sidebar":"docsSidebar"},"manual/define-problem/variables":{"id":"manual/define-problem/variables","title":"Variables","description":"Amigo components work with several types of variables, each serving a distinct purpose in defining optimization problems. Understanding these variable types is essential for building Amigo models.","sidebar":"docsSidebar"},"manual/plot-solution":{"id":"manual/plot-solution","title":"Plot a Solution","description":"This page is under construction and will be updated soon.","sidebar":"docsSidebar"},"manual/set-initial-guess":{"id":"manual/set-initial-guess","title":"Set an Initial Guess","description":"This page is under construction and will be updated soon.","sidebar":"docsSidebar"},"manual/solve-on-gpu":{"id":"manual/solve-on-gpu","title":"Solve on GPU","description":"GPU support is currently under development.","sidebar":"docsSidebar"},"manual/solve-problem":{"id":"manual/solve-problem","title":"Solve a problem","description":"Once you have defined your optimization problem by creating components and building a model, you can solve it using the Optimizer class.","sidebar":"docsSidebar"},"tutorials/background/automatic-differentiation":{"id":"tutorials/background/automatic-differentiation","title":"Automatic Differentiation","description":"This page is under construction and will be updated soon.","sidebar":"tutorialsSidebar"},"tutorials/background/direct-collocation":{"id":"tutorials/background/direct-collocation","title":"Direct Collocation","description":"This page is under construction and will be updated soon.","sidebar":"tutorialsSidebar"},"tutorials/background/discretization-methods":{"id":"tutorials/background/discretization-methods","title":"Discretization Methods","description":"This page is under construction and will be updated soon.","sidebar":"tutorialsSidebar"},"tutorials/background/interior-point-methods":{"id":"tutorials/background/interior-point-methods","title":"Interior Point Methods","description":"This page is under construction and will be updated soon.","sidebar":"tutorialsSidebar"},"tutorials/background/shooting-methods":{"id":"tutorials/background/shooting-methods","title":"Shooting Methods","description":"This page is under construction and will be updated soon.","sidebar":"tutorialsSidebar"},"tutorials/cart-pole":{"id":"tutorials/cart-pole","title":"Cart-Pole Problem","description":"For this example, we consider the well-known cart-pole problem, also called the inverted pendulum on a cart. The system consists of a cart that can move horizontally along a frictionless track, with a pole attached to it by a frictionless hinge. The state variables are $(q1, q2, \\\\dot1, \\\\dot{q}2)$ where $q1$ is the cart position, $q2$ is the pole angle from vertical downward, and $\\\\dot{q}1$, $\\\\dot{q}2$ are the corresponding velocities, for a total state dimension of 4. The system is controlled by a horizontal force $x$ applied to the cart and is subject to gravity $g$. The objective is to swing the pole from hanging downward to the upright balanced position while minimizing control effort.","sidebar":"tutorialsSidebar"},"tutorials/euler_beam":{"id":"tutorials/euler_beam","title":"Euler-Bernoulli Beam Optimization","description":"Amigo-based FEM integrated within OpenMDAO","sidebar":"tutorialsSidebar"},"tutorials/free-flying-robot":{"id":"tutorials/free-flying-robot","title":"Free Flying Robot","description":"This problem addresses the optimal trajectory planning for a free-flying robot in planar motion. The robot is equipped with two independent jet thrusters that can fire to produce thrust forces. The system must transfer from an initial equilibrium state at position $(-10, -10)$ with orientation $\\\\pi/2$ to the origin with zero orientation, all velocities starting and ending at zero. The challenge is to determine the thrust history for both actuators that minimizes total fuel consumption while satisfying the nonlinear dynamics and terminal constraints.","sidebar":"examplesSidebar"},"tutorials/hang-glider":{"id":"tutorials/hang-glider","title":"Hang Glider","description":"The hang glider problem is a classical benchmark in optimal control. The problem seeks to determine the flight path that maximizes the horizontal distance traveled while descending between two specified altitudes. The glider is modeled as a point mass subject to three forces: lift $L$, drag $D$, and weight $W = mg$. The glider flies through an atmospheric thermal updraft field that provides position-dependent vertical wind assistance.","sidebar":"examplesSidebar"},"tutorials/intro":{"id":"tutorials/intro","title":"Tutorials","description":"This collection of tutorials is part of Amigo. Amigo gathers tools for modeling and solving optimization problems and applications. It aims to provide efficient, differentiated solvers that run on both CPU and GPU.","sidebar":"tutorialsSidebar"}}}}')}}]);